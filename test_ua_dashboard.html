<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UA Buy Volume Performance Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --color-primary: #4F46E5; --color-primary-light: #EEF2FF;
      --color-success: #10B981; --color-warning: #F59E0B; --color-danger: #EF4444;
      --color-info: #06B6D4;
      --text-primary: #1F2937; --text-secondary: #6B7280; --text-muted: #9CA3AF;
      --bg-page: #F3F4F6; --bg-card: #FFFFFF; --bg-hover: #F9FAFB;
      --border-color: #E5E7EB; --border-radius: 8px; --border-radius-lg: 12px;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
      --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1);
      --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: var(--font-family); background: var(--bg-page); color: var(--text-primary); line-height: 1.5; -webkit-font-smoothing: antialiased; }
    .dashboard { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .dashboard-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid var(--border-color); }
    .dashboard-header h1 { font-size: 1.5rem; font-weight: 700; color: var(--text-primary); }
    .dashboard-header .subtitle { font-size: 0.875rem; color: var(--text-secondary); margin-top: 4px; }
    .dashboard-header .updated { font-size: 0.875rem; color: var(--text-muted); white-space: nowrap; }
    .filter-bar { display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-end; background: var(--bg-card); border-radius: var(--border-radius-lg); padding: 16px 24px; margin-bottom: 24px; box-shadow: var(--shadow-sm); border: 1px solid var(--border-color); }
    .filter-group { display: flex; flex-direction: column; gap: 4px; }
    .filter-group label { font-size: 0.875rem; font-weight: 500; color: var(--text-secondary); }
    .filter-group select, .filter-group input[type="date"] { padding: 6px 12px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.875rem; font-family: var(--font-family); color: var(--text-primary); background: var(--bg-card); min-width: 140px; transition: border-color 0.2s, box-shadow 0.2s; }
    .filter-group select:focus, .filter-group input:focus { outline: none; border-color: var(--color-primary); box-shadow: 0 0 0 3px var(--color-primary-light); }
    .filter-group select:hover, .filter-group input:hover { border-color: #D1D5DB; }
    .filter-reset { padding: 6px 16px; background: var(--bg-page); border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.875rem; color: var(--text-secondary); cursor: pointer; transition: background 0.2s; font-family: var(--font-family); }
    .filter-reset:hover { background: var(--border-color); }
    .kpi-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px; }
    .kpi-card { background: var(--bg-card); border-radius: var(--border-radius-lg); padding: 24px; box-shadow: var(--shadow-sm); border: 1px solid var(--border-color); transition: box-shadow 0.2s, transform 0.2s; }
    .kpi-card:hover { box-shadow: var(--shadow-md); transform: translateY(-1px); }
    .kpi-label { font-size: 0.875rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; font-weight: 500; }
    .kpi-value { font-size: 1.875rem; font-weight: 700; color: var(--text-primary); margin: 8px 0; line-height: 1.2; }
    .kpi-change { font-size: 0.875rem; font-weight: 600; }
    .kpi-change.positive { color: var(--color-success); }
    .kpi-change.negative { color: var(--color-danger); }
    .kpi-change.neutral { color: var(--text-muted); }
    .chart-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 16px; margin-bottom: 24px; }
    .chart-row.split { grid-template-columns: 2fr 1fr; }
    .chart-container { background: var(--bg-card); border-radius: var(--border-radius-lg); padding: 24px; box-shadow: var(--shadow-sm); border: 1px solid var(--border-color); }
    .chart-container h3 { font-size: 1rem; font-weight: 600; color: var(--text-primary); margin-bottom: 16px; }
    .chart-container .chart-subtitle { font-size: 0.875rem; color: var(--text-secondary); margin-top: -8px; margin-bottom: 16px; }
    .chart-wrapper { position: relative; height: 300px; }
    .table-container { background: var(--bg-card); border-radius: var(--border-radius-lg); padding: 24px; box-shadow: var(--shadow-sm); border: 1px solid var(--border-color); overflow-x: auto; }
    .table-container h3 { font-size: 1rem; font-weight: 600; margin-bottom: 16px; }
    .data-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
    .data-table thead { position: sticky; top: 0; z-index: 1; }
    .data-table th { text-align: left; padding: 10px 12px; font-weight: 600; color: var(--text-secondary); background: var(--bg-page); border-bottom: 2px solid var(--border-color); white-space: nowrap; user-select: none; }
    .data-table th.sortable { cursor: pointer; }
    .data-table th.sortable:hover { color: var(--color-primary); }
    .data-table td { padding: 10px 12px; border-bottom: 1px solid var(--border-color); color: var(--text-primary); }
    .data-table tbody tr:hover { background: var(--bg-hover); }
    .data-table tbody tr:last-child td { border-bottom: none; }
    .data-table td.num, .data-table th.num { text-align: right; font-variant-numeric: tabular-nums; }
    .status-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: 600; }
    .status-badge.good { background: #D1FAE5; color: #065F46; }
    .status-badge.warn { background: #FEF3C7; color: #92400E; }
    .status-badge.bad { background: #FEE2E2; color: #991B1B; }

    /* Dark mode */
    html.dark {
      --color-primary: #818CF8; --color-primary-light: #312E81;
      --color-success: #34D399; --color-warning: #FBBF24; --color-danger: #F87171; --color-info: #22D3EE;
      --text-primary: #F9FAFB; --text-secondary: #D1D5DB; --text-muted: #9CA3AF;
      --bg-page: #111827; --bg-card: #1F2937; --bg-hover: #374151;
      --border-color: #374151;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.3); --shadow-md: 0 4px 6px rgba(0,0,0,0.4); --shadow-lg: 0 10px 15px rgba(0,0,0,0.5);
    }

    .theme-toggle { position: fixed; bottom: 20px; right: 20px; width: 40px; height: 40px; border-radius: 50%; border: 1px solid var(--border-color); background: var(--bg-card); color: var(--text-primary); font-size: 18px; cursor: pointer; box-shadow: var(--shadow-md); display: flex; align-items: center; justify-content: center; transition: transform 0.2s; z-index: 1000; }
    .theme-toggle:hover { transform: scale(1.1); }

    @media (max-width: 768px) {
      .dashboard { padding: 16px; }
      .dashboard-header { flex-direction: column; gap: 8px; }
      .kpi-row { grid-template-columns: repeat(2, 1fr); }
      .chart-row, .chart-row.split { grid-template-columns: 1fr; }
      .filter-bar { flex-direction: column; }
      .filter-group { width: 100%; }
      .filter-group select, .filter-group input { width: 100%; }
    }
    @media (max-width: 480px) {
      .kpi-row { grid-template-columns: 1fr; }
      .kpi-value { font-size: 1.5rem; }
      .chart-wrapper { height: 250px; }
      .data-table { font-size: 0.75rem; }
      .data-table th, .data-table td { padding: 8px 6px; }
    }
    @media print {
      body { background: white; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
      .dashboard { max-width: none; padding: 0; }
      .filter-bar { display: none; }
      .theme-toggle { display: none; }
      .kpi-card, .chart-container, .table-container { box-shadow: none; border: 1px solid #ddd; break-inside: avoid; page-break-inside: avoid; }
      .chart-row { grid-template-columns: repeat(2, 1fr); }
      .chart-wrapper { height: 250px; }
    }
  </style>
</head>
<body>
  <div class="dashboard">
    <header class="dashboard-header">
      <div>
        <h1>UA Buy Volume Performance Dashboard</h1>
        <p class="subtitle">User Acquisition metrics across all channels - Last 30 days</p>
      </div>
      <span class="updated">Updated: <span id="lastUpdated"></span></span>
    </header>

    <div class="filter-bar" id="filterBar">
      <!-- Dynamically rendered -->
    </div>

    <div class="kpi-row" id="kpiRow">
      <!-- Dynamically rendered -->
    </div>

    <div class="chart-row split">
      <div class="chart-container">
        <h3>CPI Trend - Last 30 Days</h3>
        <p class="chart-subtitle">Cost Per Install by channel over time</p>
        <div class="chart-wrapper"><canvas id="cpiTrendChart"></canvas></div>
      </div>
      <div class="chart-container">
        <h3>Install Distribution by Channel</h3>
        <p class="chart-subtitle">Share of total installs</p>
        <div class="chart-wrapper"><canvas id="installDistChart"></canvas></div>
      </div>
    </div>

    <div class="chart-row">
      <div class="chart-container">
        <h3>ROAS by Channel</h3>
        <p class="chart-subtitle">Return on Ad Spend comparison</p>
        <div class="chart-wrapper"><canvas id="roasBarChart"></canvas></div>
      </div>
    </div>

    <div class="table-container">
      <h3>Top 10 Creative Performance</h3>
      <div id="dataTable"></div>
    </div>
  </div>

  <button class="theme-toggle" onclick="toggleTheme()" title="Toggle dark mode">
    <span id="themeIcon">&#9789;</span>
  </button>

  <script>
    // ========== COLOR PALETTE ==========
    const COLORS = [
      '#4F46E5', '#06B6D4', '#10B981', '#F59E0B', '#EF4444',
      '#8B5CF6', '#EC4899', '#14B8A6', '#F97316', '#6366F1'
    ];

    const CHANNEL_COLORS = {
      'Facebook': '#4F46E5',
      'Google': '#06B6D4',
      'TikTok': '#10B981',
      'Unity Ads': '#F59E0B'
    };

    // ========== SAMPLE DATA: Daily channel-level UA metrics (30 days) ==========
    const RAW_DATA = generateSampleData();

    function generateSampleData() {
      const channels = ['Facebook', 'Google', 'TikTok', 'Unity Ads'];
      const data = [];
      const baseDate = new Date('2026-01-08');

      // Base metrics per channel (daily averages)
      const channelProfiles = {
        'Facebook':  { installs: 850, spend: 2800, revenue: 4200, impressions: 120000, clicks: 7200 },
        'Google':    { installs: 720, spend: 2100, revenue: 3600, impressions: 95000,  clicks: 5700 },
        'TikTok':    { installs: 550, spend: 1400, revenue: 1960, impressions: 180000, clicks: 9000 },
        'Unity Ads': { installs: 380, spend: 760,  revenue: 1140, impressions: 65000,  clicks: 3900 }
      };

      for (let dayOffset = 0; dayOffset < 30; dayOffset++) {
        const date = new Date(baseDate);
        date.setDate(date.getDate() + dayOffset);
        const dateStr = date.toISOString().split('T')[0];
        const dayOfWeek = date.getDay();
        // Weekend boost factor
        const weekendFactor = (dayOfWeek === 0 || dayOfWeek === 6) ? 1.15 : 1.0;
        // Slight upward trend
        const trendFactor = 1 + (dayOffset / 30) * 0.12;

        for (const channel of channels) {
          const base = channelProfiles[channel];
          const noise = () => 0.85 + Math.random() * 0.30; // +/- 15%

          const installs = Math.round(base.installs * weekendFactor * trendFactor * noise());
          const spend = Math.round(base.spend * weekendFactor * trendFactor * noise() * 100) / 100;
          const revenue = Math.round(base.revenue * weekendFactor * trendFactor * noise() * 100) / 100;
          const impressions = Math.round(base.impressions * weekendFactor * trendFactor * noise());
          const clicks = Math.round(base.clicks * weekendFactor * trendFactor * noise());

          data.push({
            date: dateStr,
            channel,
            installs,
            spend,
            revenue,
            impressions,
            clicks
          });
        }
      }
      return data;
    }

    // ========== CREATIVE PERFORMANCE DATA ==========
    const CREATIVE_DATA = [
      { name: 'video_gameplay_v3', channel: 'Facebook', impressions: 2450000, ctr: 6.2, installs: 18200, cpi: 2.85 },
      { name: 'ugc_review_01', channel: 'TikTok', impressions: 3800000, ctr: 5.8, installs: 15600, cpi: 1.92 },
      { name: 'playable_demo_v2', channel: 'Google', impressions: 1890000, ctr: 4.5, installs: 12400, cpi: 3.12 },
      { name: 'carousel_features', channel: 'Facebook', impressions: 1650000, ctr: 3.8, installs: 9800, cpi: 3.45 },
      { name: 'tiktok_trend_02', channel: 'TikTok', impressions: 4200000, ctr: 4.1, installs: 9200, cpi: 2.15 },
      { name: 'reward_video_01', channel: 'Unity Ads', impressions: 980000, ctr: 7.1, installs: 8500, cpi: 1.78 },
      { name: 'story_cinematic', channel: 'Facebook', impressions: 1200000, ctr: 3.2, installs: 7600, cpi: 3.68 },
      { name: 'search_brand_v1', channel: 'Google', impressions: 750000, ctr: 8.5, installs: 7200, cpi: 2.95 },
      { name: 'interstitial_v4', channel: 'Unity Ads', impressions: 1100000, ctr: 5.5, installs: 6800, cpi: 1.95 },
      { name: 'short_gameplay_15s', channel: 'TikTok', impressions: 5600000, ctr: 3.0, installs: 6500, cpi: 2.38 }
    ];

    // ========== DASHBOARD CLASS ==========
    class Dashboard {
      constructor(rawData, creativeData) {
        this.rawData = rawData;
        this.creativeData = creativeData;
        this.filteredData = [...rawData];
        this.filteredCreatives = [...creativeData];
        this.charts = {};
        this.sortKey = 'installs';
        this.sortDir = 'desc';
        this.init();
      }

      init() {
        this.renderFilters();
        this.applyFilters();
        document.getElementById('lastUpdated').textContent = new Date().toLocaleString('zh-CN');
      }

      applyFilters() {
        const channel = document.getElementById('filterChannel')?.value || 'all';
        const dateFrom = document.getElementById('filterDateFrom')?.value || '';
        const dateTo = document.getElementById('filterDateTo')?.value || '';

        this.filteredData = this.rawData.filter(row => {
          if (channel !== 'all' && row.channel !== channel) return false;
          if (dateFrom && row.date < dateFrom) return false;
          if (dateTo && row.date > dateTo) return false;
          return true;
        });

        this.filteredCreatives = channel !== 'all'
          ? this.creativeData.filter(c => c.channel === channel)
          : [...this.creativeData];

        this.renderKPIs();
        this.renderCharts();
        this.renderTable();
      }

      renderFilters() {
        const channels = [...new Set(this.rawData.map(r => r.channel))].sort();
        const dates = this.rawData.map(r => r.date).sort();

        document.getElementById('filterBar').innerHTML = `
          <div class="filter-group">
            <label>Channel</label>
            <select id="filterChannel" onchange="dashboard.applyFilters()">
              <option value="all">All Channels</option>
              ${channels.map(c => `<option value="${c}">${c}</option>`).join('')}
            </select>
          </div>
          <div class="filter-group">
            <label>Date From</label>
            <input type="date" id="filterDateFrom" value="${dates[0] || ''}" onchange="dashboard.applyFilters()">
          </div>
          <div class="filter-group">
            <label>Date To</label>
            <input type="date" id="filterDateTo" value="${dates[dates.length - 1] || ''}" onchange="dashboard.applyFilters()">
          </div>
          <button class="filter-reset" onclick="dashboard.resetFilters()">Reset</button>
        `;
      }

      resetFilters() {
        this.renderFilters();
        this.applyFilters();
      }

      // ========== KPIs ==========
      renderKPIs() {
        const data = this.filteredData;
        const totalSpend = data.reduce((s, r) => s + r.spend, 0);
        const totalInstalls = data.reduce((s, r) => s + r.installs, 0);
        const totalRevenue = data.reduce((s, r) => s + r.revenue, 0);
        const avgCPI = totalInstalls > 0 ? totalSpend / totalInstalls : 0;
        const roas = totalSpend > 0 ? totalRevenue / totalSpend : 0;

        // Compute period-over-period changes (first half vs second half of filtered period)
        const sortedDates = [...new Set(data.map(r => r.date))].sort();
        const midpoint = Math.floor(sortedDates.length / 2);
        const firstHalfDates = new Set(sortedDates.slice(0, midpoint));
        const secondHalfDates = new Set(sortedDates.slice(midpoint));

        const firstHalf = data.filter(r => firstHalfDates.has(r.date));
        const secondHalf = data.filter(r => secondHalfDates.has(r.date));

        const fhSpend = firstHalf.reduce((s, r) => s + r.spend, 0);
        const shSpend = secondHalf.reduce((s, r) => s + r.spend, 0);
        const fhInstalls = firstHalf.reduce((s, r) => s + r.installs, 0);
        const shInstalls = secondHalf.reduce((s, r) => s + r.installs, 0);
        const fhRevenue = firstHalf.reduce((s, r) => s + r.revenue, 0);
        const shRevenue = secondHalf.reduce((s, r) => s + r.revenue, 0);
        const fhCPI = fhInstalls > 0 ? fhSpend / fhInstalls : 0;
        const shCPI = shInstalls > 0 ? shSpend / shInstalls : 0;
        const fhROAS = fhSpend > 0 ? fhRevenue / fhSpend : 0;
        const shROAS = shSpend > 0 ? shRevenue / shSpend : 0;

        const pctChange = (newer, older) => older > 0 ? ((newer - older) / older * 100) : 0;

        const spendChange = pctChange(shSpend, fhSpend);
        const installChange = pctChange(shInstalls, fhInstalls);
        const cpiChange = pctChange(shCPI, fhCPI);
        const roasChange = pctChange(shROAS, fhROAS);

        const kpis = [
          {
            label: 'Total Spend',
            value: `$${this.formatNumber(totalSpend)}`,
            change: `${spendChange >= 0 ? '+' : ''}${spendChange.toFixed(1)}%`,
            positive: true, // Spend increase is neutral/expected
            cls: spendChange > 10 ? 'negative' : spendChange > 0 ? 'neutral' : 'positive'
          },
          {
            label: 'Total Installs',
            value: this.formatNumber(totalInstalls),
            change: `${installChange >= 0 ? '+' : ''}${installChange.toFixed(1)}%`,
            cls: installChange >= 0 ? 'positive' : 'negative'
          },
          {
            label: 'Avg CPI',
            value: `$${avgCPI.toFixed(2)}`,
            change: `${cpiChange >= 0 ? '+' : ''}${cpiChange.toFixed(1)}%`,
            cls: cpiChange <= 0 ? 'positive' : 'negative' // Lower CPI is better
          },
          {
            label: 'Overall ROAS',
            value: `${roas.toFixed(2)}x`,
            change: `${roasChange >= 0 ? '+' : ''}${roasChange.toFixed(1)}%`,
            cls: roasChange >= 0 ? 'positive' : 'negative'
          }
        ];

        document.getElementById('kpiRow').innerHTML = kpis.map(kpi => `
          <div class="kpi-card">
            <div class="kpi-label">${kpi.label}</div>
            <div class="kpi-value">${kpi.value}</div>
            <div class="kpi-change ${kpi.cls}">
              ${kpi.cls === 'positive' ? '&#9650;' : kpi.cls === 'negative' ? '&#9660;' : '&#9654;'} ${kpi.change}
              <span style="font-weight:400; color: var(--text-muted); margin-left: 4px;">vs prev period</span>
            </div>
          </div>
        `).join('');
      }

      // ========== CHARTS ==========
      renderCharts() {
        this.renderCPITrendChart();
        this.renderInstallDistChart();
        this.renderROASBarChart();
      }

      renderCPITrendChart() {
        const grouped = this.groupBy(this.filteredData, 'date');
        const dates = Object.keys(grouped).sort();

        // Get channels present in filtered data
        const channels = [...new Set(this.filteredData.map(r => r.channel))].sort();

        const datasets = channels.map((ch, i) => {
          const values = dates.map(d => {
            const rows = grouped[d].filter(r => r.channel === ch);
            const spend = rows.reduce((s, r) => s + r.spend, 0);
            const installs = rows.reduce((s, r) => s + r.installs, 0);
            return installs > 0 ? Math.round(spend / installs * 100) / 100 : 0;
          });
          return {
            label: ch,
            data: values,
            borderColor: CHANNEL_COLORS[ch] || COLORS[i],
            backgroundColor: 'transparent',
            fill: false,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2
          };
        });

        // Format dates for display: MM/DD
        const labels = dates.map(d => {
          const parts = d.split('-');
          return `${parts[1]}/${parts[2]}`;
        });

        if (this.charts.cpiTrend) this.charts.cpiTrend.destroy();
        this.charts.cpiTrend = new Chart(document.getElementById('cpiTrendChart'), {
          type: 'line',
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { usePointStyle: true, padding: 16 }
              },
              tooltip: {
                backgroundColor: 'rgba(0,0,0,0.8)',
                titleFont: { size: 13 },
                bodyFont: { size: 12 },
                padding: 12,
                callbacks: {
                  label: ctx => `${ctx.dataset.label}: $${ctx.raw.toFixed(2)}`
                }
              }
            },
            scales: {
              x: { grid: { display: false }, ticks: { maxTicksLimit: 15 } },
              y: {
                beginAtZero: false,
                grid: { color: 'rgba(0,0,0,0.06)' },
                ticks: {
                  callback: v => '$' + v.toFixed(2),
                  maxTicksLimit: 8
                }
              }
            }
          }
        });
      }

      renderInstallDistChart() {
        const grouped = this.groupBy(this.filteredData, 'channel');
        const labels = Object.keys(grouped).sort();
        const values = labels.map(ch => grouped[ch].reduce((s, r) => s + r.installs, 0));
        const colors = labels.map(ch => CHANNEL_COLORS[ch] || COLORS[labels.indexOf(ch)]);

        if (this.charts.installDist) this.charts.installDist.destroy();
        this.charts.installDist = new Chart(document.getElementById('installDistChart'), {
          type: 'doughnut',
          data: {
            labels,
            datasets: [{
              data: values,
              backgroundColor: colors,
              borderWidth: 2,
              borderColor: getComputedStyle(document.documentElement).getPropertyValue('--bg-card').trim() || '#fff',
              hoverOffset: 8
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: '60%',
            plugins: {
              legend: {
                position: 'right',
                labels: { usePointStyle: true, padding: 16, font: { size: 12 } }
              },
              tooltip: {
                callbacks: {
                  label: ctx => {
                    const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                    const pct = ((ctx.raw / total) * 100).toFixed(1);
                    return `${ctx.label}: ${ctx.raw.toLocaleString()} installs (${pct}%)`;
                  }
                }
              }
            }
          }
        });
      }

      renderROASBarChart() {
        const grouped = this.groupBy(this.filteredData, 'channel');
        const labels = Object.keys(grouped).sort();
        const values = labels.map(ch => {
          const rows = grouped[ch];
          const spend = rows.reduce((s, r) => s + r.spend, 0);
          const revenue = rows.reduce((s, r) => s + r.revenue, 0);
          return spend > 0 ? Math.round(revenue / spend * 100) / 100 : 0;
        });
        const colors = labels.map(ch => CHANNEL_COLORS[ch] || COLORS[labels.indexOf(ch)]);

        if (this.charts.roasBar) this.charts.roasBar.destroy();
        this.charts.roasBar = new Chart(document.getElementById('roasBarChart'), {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label: 'ROAS',
              data: values,
              backgroundColor: colors,
              borderRadius: 4,
              borderSkipped: false,
              barPercentage: 0.6,
              categoryPercentage: 0.7
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: ctx => `ROAS: ${ctx.raw.toFixed(2)}x`
                }
              }
            },
            scales: {
              x: { grid: { display: false } },
              y: {
                beginAtZero: true,
                grid: { color: 'rgba(0,0,0,0.06)' },
                ticks: {
                  callback: v => v.toFixed(1) + 'x',
                  maxTicksLimit: 8
                }
              }
            }
          }
        });
      }

      // ========== TABLE ==========
      renderTable() {
        const columns = [
          { key: 'name', label: 'Creative Name', format: 'text' },
          { key: 'channel', label: 'Channel', format: 'text' },
          { key: 'impressions', label: 'Impressions', format: 'number' },
          { key: 'ctr', label: 'CTR', format: 'percent' },
          { key: 'installs', label: 'Installs', format: 'number' },
          { key: 'cpi', label: 'CPI', format: 'currency' }
        ];

        const sortKey = this.sortKey || 'installs';
        const sortDir = this.sortDir || 'desc';
        const sorted = [...this.filteredCreatives].sort((a, b) => {
          const aVal = a[sortKey];
          const bVal = b[sortKey];
          if (typeof aVal === 'string') {
            return sortDir === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
          }
          return sortDir === 'asc' ? (aVal - bVal) : (bVal - aVal);
        });

        const formatVal = (val, fmt) => {
          if (fmt === 'currency') return '$' + val.toFixed(2);
          if (fmt === 'number') return val.toLocaleString();
          if (fmt === 'percent') return val.toFixed(1) + '%';
          return val;
        };

        const getCPIBadge = (cpi) => {
          if (cpi < 2.0) return '<span class="status-badge good">Low</span>';
          if (cpi < 3.0) return '<span class="status-badge warn">Mid</span>';
          return '<span class="status-badge bad">High</span>';
        };

        document.getElementById('dataTable').innerHTML = `
          <table class="data-table">
            <thead>
              <tr>
                ${columns.map(col => `
                  <th class="sortable ${col.format !== 'text' ? 'num' : ''}"
                      onclick="dashboard.sortBy('${col.key}')">
                    ${col.label} ${sortKey === col.key ? (sortDir === 'asc' ? '&#9650;' : '&#9660;') : ''}
                  </th>
                `).join('')}
                <th>Rating</th>
              </tr>
            </thead>
            <tbody>
              ${sorted.map(row => `
                <tr>
                  ${columns.map(col => {
                    const val = row[col.key];
                    const cls = col.format !== 'text' ? ' class="num"' : '';
                    return `<td${cls}>${formatVal(val, col.format)}</td>`;
                  }).join('')}
                  <td>${getCPIBadge(row.cpi)}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        `;
      }

      sortBy(key) {
        if (this.sortKey === key) {
          this.sortDir = this.sortDir === 'asc' ? 'desc' : 'asc';
        } else {
          this.sortKey = key;
          this.sortDir = 'desc';
        }
        this.renderTable();
      }

      // ========== UTILITY ==========
      groupBy(data, key) {
        return data.reduce((acc, row) => {
          (acc[row[key]] = acc[row[key]] || []).push(row);
          return acc;
        }, {});
      }

      formatNumber(num) {
        if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
        if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
        return num.toLocaleString();
      }
    }

    // ========== THEME TOGGLE ==========
    function toggleTheme() {
      document.documentElement.classList.toggle('dark');
      const icon = document.getElementById('themeIcon');
      const isDark = document.documentElement.classList.contains('dark');
      icon.textContent = isDark ? '\u2600' : '\u263D';
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
    }

    // Restore saved theme
    if (localStorage.getItem('theme') === 'dark') {
      document.documentElement.classList.add('dark');
      document.addEventListener('DOMContentLoaded', () => {
        const el = document.getElementById('themeIcon');
        if (el) el.textContent = '\u2600';
      });
    }

    // ========== INITIALIZE ==========
    const dashboard = new Dashboard(RAW_DATA, CREATIVE_DATA);
  </script>
</body>
</html>
